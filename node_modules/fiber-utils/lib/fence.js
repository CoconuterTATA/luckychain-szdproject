// Generated by CoffeeScript 1.12.4
(function() {
  var OrderedFence, _, assert,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ = require('underscore');

  assert = require('assert');

  OrderedFence = (function() {
    function OrderedFence(Fiber, Future, arg) {
      this.Fiber = Fiber;
      this.Future = Future;
      this.allowRecursive = arg.allowRecursive, this.allowNested = arg.allowNested, this.breakDeadlocks = arg.breakDeadlocks;
      if (this.allowRecursive == null) {
        this.allowRecursive = true;
      }
      if (this.allowNested == null) {
        this.allowNested = true;
      }
      if (this.breakDeadlocks == null) {
        this.breakDeadlocks = true;
      }
      this._futures = [];
      this._currentFiber = null;
    }

    OrderedFence.prototype.enter = function() {
      var base, base1, dependedFiber, future, node, ownFuture, queue, visited;
      if (this.Fiber.current === this._currentFiber) {
        if (!this.allowRecursive) {
          throw new Error("Recursive reentry of guarded section within the same fiber not allowed.");
        }
        return false;
      }
      if (this.Fiber.current._guardsActive > 0 && !this.allowNested) {
        throw new Error("Nesting of guarded sections is not allowed.");
      }
      dependedFiber = null;
      if (this._currentFiber) {
        if ((base = this.Fiber.current)._dependencies == null) {
          base._dependencies = [];
        }
        this.Fiber.current._dependencies.push(this._currentFiber);
        dependedFiber = this._currentFiber;
        visited = [];
        queue = [this.Fiber.current];
        while (true) {
          node = queue.shift();
          if (!node) {
            break;
          }
          if (indexOf.call(visited, node) >= 0) {
            if (this.breakDeadlocks) {
              this.Fiber.current._dependencies = _.without(this.Fiber.current._dependencies, this._currentFiber);
              throw new Error("Dependency cycle detected between guarded sections.");
            }
            console.warn("Dependency cycle detected between guarded sections. Deadlock not broken.");
            break;
          }
          visited.push(node);
          queue = queue.concat(node._dependencies);
        }
        queue = null;
        visited = null;
      }
      future = null;
      if (!_.isEmpty(this._futures)) {
        future = this._futures[this._futures.length - 1];
      }
      ownFuture = new this.Future();
      this._futures.push(ownFuture);
      if (future != null) {
        future.wait();
      }
      if (dependedFiber) {
        this.Fiber.current._dependencies = _.without(this.Fiber.current._dependencies, dependedFiber);
      }
      assert(this._futures[0] === ownFuture);
      assert(!this._currentFiber);
      this._currentFiber = this.Fiber.current;
      if ((base1 = this._currentFiber)._guardsActive == null) {
        base1._guardsActive = 0;
      }
      this._currentFiber._guardsActive++;
      return true;
    };

    OrderedFence.prototype.exit = function(topLevel) {
      var ref;
      if (!topLevel) {
        return;
      }
      assert(this._currentFiber._guardsActive > 0);
      this._currentFiber._guardsActive--;
      this._currentFiber = null;
      return (ref = this._futures.shift()) != null ? ref["return"]() : void 0;
    };

    OrderedFence.prototype.isInUse = function() {
      return this._futures.length > 0;
    };

    return OrderedFence;

  })();

  module.exports = {
    OrderedFence: OrderedFence
  };

}).call(this);

//# sourceMappingURL=fence.js.map
